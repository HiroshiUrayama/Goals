'#############################
'機能
'#############################
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'SCHEMA
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
多数のデータベースの格納先を、
テーブルの目的や所有者に応じて分類する仕組み。
    ※データベース内で、テーブルなどのオブジェクトを格納している名前空間のこと。

特徴：
    1.データベース内のオブジェクトは必ず単一のスキーマに格納される
    2.各スキーマでは、他スキーマと名称の同じオブジェクトを作成することができる。
    3.スキーマは複数のユーザに使用されることができ、
    　ユーザも複数のスキーマを所有・操作することができる。

        ※データベースクラスタ作成時にデフォルトでpublicスキーマが作成される。
        ※オブジェクトを作成する場合は「スキーマ名.オブジェクト名」で所属するスキーマを指定する
            but スキーマ名を省略するとpublicスキーマが指定される。
        ※current_schema()関数を使用することで、現在のスキーマが取得できる。

    CREATE SCHEMA(スキーマを作る)
        書式：
            CREATE SCHEMA スキーマ名[AUTHORIZATION 所有者名];
                所有者名の指定を省略した場合は、SQLを実行したデータベースユーザ名が設定される。
        
        問題から：
            user1ユーザに所有権があるtestスキーマを作成する
                CREATE SCHEMA test AUTORIZATION　user1;

    ALTER SCHEMA(スキーマの定義を変更する)
        
        スキーマの名称を変更する
            ALTER SCHEMA スキーマ名 RENAME TO 新しいスキーマ名;

        スキーマの所有者を変更する
            ALTER SCHEMA スキーマ名 OWNER TO 新しい所有者名;

    DROP SCHEMA
        DROP SCHEMA スキーマ名[CASCADE];
            対象のスキーマにオブジェクトが存在する場合は、
            CASCADEを設定すると関連するオブジェクトを纏めて削除することができる。
                対象のスキーマにオブジェクトが存在する場合は、
                CASCADEを設定しないとエラーになる。

    定義した特定のスキーマにアクセスしたい場合
        1.オブジェクトの名称をスキーマ名で修飾する
            (例)「test」スキーマの「sample」テーブルにアクセスしたい
                text.sampleと記述する

        2.search_pathパラメータに対象のスキーマを指定する
            testスキーマのsampleテーブルにアクセスしたい場合
                SET search_path TO test, "$user" , public;
                SELECT * FROM sample;
        
        "$user"は、現在のデータベースユーザ名が設定される。
        search_pathのTOの左側にあるスキーマの優先度が一番高い。
        スキーマがたくさんあっても、TOの後の一番優先度が高いスキーマからデータを持ってくる。
            つまり、スキーマ名を指定しない場合は
                1.データベースユーザ名と同じ名前のスキーマ
                2.sampleスキーマ
                3.publicスキーマ
                    での優先順位で検索対象となる。
                        ∴取得されるデータは検索対象となったスキーマのデータのみ。
        search_pathパラメータの設定にはデフォルトで「"$user" , public」が設定されている。
        search_pathパラメータの設定にスーパユーザ権限は必要ない。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'TABLE
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
特徴：
    1.作成した直後のテーブルにはデータが存在しない(0件)
    2.定義できるカラム数は、データ型によって250～1,600
    3.テーブル名には英数字・日本が使用できる
    4.「"」で囲むことにより、大文字・小文字を区別してテーブルを作成することができる
    5.カラムにデフォルト値を指定しない場合、値を設定せずにデータを挿入すると
    NULLが格納される(=カラムのデフォルト値はNULL)
    6.カラムの値を変更する場合はUPDATEを使う(ALTER TABLEはテーブル定義)
    7.設定できる制約数に制限はない。
    8.テーブル名は、""で囲むと大文字、小文字を区別する。
        囲まなくても特にエラーが出たりはしない。

コマンド：
    1.CREATE TABLE
        書式：
            CREATE TABLE 
                テーブル名
                    (カラム名 データ型[デフォルト値][制約]
                        [, カラム名 データ型[デフォルト値][制約]...]);

                ※制約に関しては別部分で記載した
                ※制約「名」を省略した場合はシステムが自動で設定する。

    主キー制約を設定する
        単一カラム
            CREATE TABLE テーブル名(カラム名 データ型 PRIMARY KEY);
        複数カラム
            CREATE TABLE テーブル名(カラム名 データ型 [, カラム名 データ型...],
            [CONSTRAINT 制約名] PRIMARY KEY (カラム名[, カラム名...]));

    UNIQUE制約を設定する
        単一カラム
            CREATE TABLE テーブル名(カラム名 データ型 UNIQUE);
        複数カラム
            CREATE TABLE テーブル名(カラム名 データ型[, カラム名 データ型...],
            [CONSTRAINT 制約名] UNIQUE (カラム名[, カラム名...]));

    NOT NULL制約を設定する
        単一カラムだけ？
            CREATE TABLE テーブル名(カラム データ型 NOT NULL);

    外部キー制約を設定する場合
        単一カラム
            CREATE TABLE テーブル名
            (カラム名 データ型 REFERENCES 参照先テーブル名(カラム名));
        複数カラム
            CREATE TABLE テーブル名
            (カラム名 データ型[, カラム名 データ型...],[CONSTRAINT 制約名]
            FOREIGN KEY(カラム名) REFERENCES 参照先テーブル名(カラム名[, カラム名...]));

        問題から
            CREATE TABLE 
            sample(no INTEGER REFERENCES sample_1(id), name TEXT);
            ↑FOREIGN KEYはいらない

            CREATE TABLE
            sample(no INTEGER, name TEXT, FOREIGN KEY(no)REFERENCES sample_1(id));

        説明
            参照テーブルに存在しない値を格納させない制約のこと。
                参照先のテーブルとデータの整合性を担保することができる。
                    外部キーとなるカラムは、主キー制約かユニーク制約が設定されている必要がある。
                    
    CHECK制約を設定する場合
        単一カラム
            CREATE TABLE テーブル名(カラム名 データ型 CHECK(条件式));
            CREATE TABLE テーブル名(カラム名 データ型[, カラム名 データ型...],
            [CONSTRAINT 制約名] CHECK (条件式));

    2.ALTER TABLE(テーブル定義を変更するコマンド)
        書式：

            【テーブルに対する変更】
            テーブル名を変更する
                ALTER TABLE テーブル名 RENAME TO 新しいテーブル名;
            
            【カラムに対する変更】
            カラム名を変更する
                ALTER TABLE テーブル名 RENAME COLUMN TO 新しいカラム名;
            カラムを追加する場合
                ALTER TABLE テーブル名 ADD COLUMN 追加するカラム名 データ型;
            カラムを削除する場合
                ALTER TABLE テーブル名 DROP COLUMN 削除するカラム名;
            (カラムの)デフォルト値を設定する場合
                ALTER TABLE テーブル名 ALTER COLUMN カラム名 SET DEFAULT デフォルト値;
                
                問題から
                    ALTER TABLE sample ALTER COLUMN groupName SET DEFAULT '営業部';
                        sampleテーブルのgroupNameカラムにデフォルト値'営業部'を設定する
            (カラムの)デフォルト値を削除する場合
                ALTER TABLE テーブル名 ALTER COLUMN カラム名 DROP DEFAULT;
            (カラムの)データ型を変更する場合(VER9.1で追加)
                ALTER TABLE テーブル名 ALTER COLUMN カラム名 SET DATA TYPE 新しいデータ型;

            【制約の設定・削除】
            制約名を省略するとシステムが自動で決めてくれる
            主キー制約を設定
                ALTER TABLE テーブル名 ADD[CONSTRAINT 制約名] PRIMARY KEY(カラム名);

            主キー制約を削除
                ALTER TABLE テーブル名 DROP CONSTRAINT 制約名;

            UNIQUE制約を設定
                ALTER TABLE テーブル名 ADD[CONSTRAINT 制約名] UNIQUE(カラム名);

            UNIQUE制約を削除
                ALTER TABLE テーブル名 DROP CONSTRAINT 制約名;

            外部キー制約を設定
                ALTER TABLE テーブル名 ADD[CONSTRAINT 制約名] FOREIGN KEY(カラム名)
                REFERENCES 参照先テーブル名(カラム名);

            外部キー制約を削除
                ALTER TABLE テーブル名 DROP CONSTRAINT 制約名;
            
            ///割愛(ほとんど書き方一緒)

    3.DROP TABLE

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'VIEW
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
複雑なSQL文のSELECT結果を頻繁に使用したい場合、
SELECT文の結果をテーブルのように定義することができる：これがビュー

権限：
    ビューに対するSELECT文の権限が必要。
    ※ビューのもとになるSELECT文に対するSELECT権限がなくても、ビューの参照が可能。

規則：
    テーブルなどのオブジェクトと同じように、同一スキーマ内の既存のオブジェクトに使われている
    名前は使用できない。

確認：
    システムカタログの「pg_views」で確認可能。

ビューにデータ更新ができる(9.3～)：
    条件①：複数テーブルの結合を行っていないこと
    条件②：集約関数(複数の数値データに対して処理を行った結果を返す関数)
                を使用していないこと

    問題から：
        CREATE VIEW sample_view
        AS SELECT * FROM sample
        WHERE memo != '特になし';
            ①の条件、②の条件を満たしているので、
            このビューに対して実行できるコマンドは、
                SELECT, INSERT, UPDATE, DELETEである。
                    Ver9.3以降はルールを作成しなくてもINSERT, UPDATE, DELETEができるように。

ビュー管理のSQLコマンド：
    CREATE VIEW
        ビューを作成するコマンド。
            ビューの元となるテーブルに対してSELECT権限が必要。
                書式
                    CREATE [OR REPLACE] VIEW ビュー名 [(カラム名)] AS 検索処理;
                        OR REPLACEをつけると既に作成済みのビューを置き換えることができる。

    ALTER VIEW
        ビューの定義を変更するコマンド。
        ビューの所有者のみ実行可能。
            書式
                カラムのデフォルト値を変更する場合
                ALTER VIEW ビュー名 ALTER [COLUMN] カラム名 SET DEFAULT デフォルト値;

                カラムのデフォルト値を削除する場合
                ALTER VIEW ビュー名 ALTER [COLUMN] カラム名 DROP DEFAULT;

                ビューの所有者を変更する場合
                ALTER VIEW ビュー名 OWNER TO 新しい所有者名;

                ビューの名称を変更する場合
                ALTER VIEW ビュー名 RENAME TO 新しいビュー名;

    DROP VIEW
        ビューを削除するコマンド
        ビューの所有者のみ実行可能。
            書式
                DROP VIEW ビュー名;

    ※処理の度にビューからビュー元に対してアクセスが発生するため、
        必要以上にビューの検索処理ばかりを繰り返すと逆に効率が下がる。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'VIEW：CREATE RULE
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
【更新可能にする】
    ルールを定義することでビューやビューのもとになるテーブルに対して更新処理を可能にする。
        ルールとは特定のSQL文に対して指定したSQL文への置き換えを定義したもの。
            対象のSQL文が実行されると置き換えられた別のSQLが処理される。
                PostgreSQLでは、ビューの実装にも使用されている。

    ルールを使用しない場合、更新処理を行うことができないビューの条件
        ・複数テーブルの結合を行っている
        ・集約関数(複数の数値データに対して処理を行った結果を返す関数)を使用している

CREATE RULE
    書式
        CREATE [OR REPLACE] RULE ルール名 AS ON イベント TO テーブル/ビュー名_
            DO 元の処理の扱い {実行するSQL文 | NOTHING};
                NOTHINGを指定した場合は、置き換え対象のSQL文が実行された際に何の処理も実行しない。
        
    問題から
    CREATE RULE sample_rule         sample_ruleを作成する
    AS ON INSERT TO sample_view sample_ruleにインサートしたときに
    DO INSTEAD(                             sample_viewにはインサートしないで、↓のインサート文を実行する
　　INSERT INTO log_memory VALUES('sample_view', 'INSERT', NEW, now()););
        ↑インサートはlog_memoryテーブルのみ。

    【主なオプション】
    ○イベント
        SELECT
            指定したテーブルに対してのSELECT処理を置き換える。

        INSERT
            指定したテーブルに対してのNSERT処理を置き換える。

        UPDATE
            指定したテーブルに対してのUPDATE処理を置き換える。

        DELETE
            指定したテーブルに対してのDELETE処理を置き換える。

    ○元の処理の扱い
        INSTEAD
            イベントで指定した処理は実行せずに、ルールで指定した処理のみを実行する
                NOTHINGをつけた場合はルール指定していても何も起こらない

        ALSO
            イベントで指定した処理に加えて、ルールで指定した処理も実行する

ALTER RULE(ルールの定義を変更するコマンド)
    変更できるのはルールの名称のみ。
    ルールを適用するテーブルか、ビューの所有者のみ実行可能。
    書式
        ALTER RULE ルール名 ON テーブル/ビュー名 RENAME TO 新しいルール名;

DROP RULE(ルールを削除するコマンド)
    ルールを適用するテーブルか、ビューの所有者のみ実行可能。
    書式
        DROP RULE ルール名 ON テーブル/ビュー名;


'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'VIEW：ALTER RULE／ルールの定義を変更するコマンド
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ルールの名称だけ変更できる。
    ルールを適用するテーブルまたはビューの所有者だけ実行可能。

    書式
        ALTER RULE ルール名 ON テーブル/ビュー名 RENAME TO 新しいルール名;

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'VIEW：DROP RULE／ルールを破棄するコマンド
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
    ルールを適用するテーブルまたはビューの所有者だけ実行可能。

    書式
        DROP RULE ルール名 ON テーブル/ビュー名;
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'MATERIALIZED VIEW
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
バージョン9.3からマテリアライズドビューが実装
ビューと同じように、複雑なSQLのSELECT結果を頻繁に取得する場合に使用する。
ビューを定義するSQL文にはORDER BY句やLIMIT句を使用できる。
    ビューに対してインデックスを作成することも可能。

ビュー
    定義したSQL文で取得するデータを保持しない
マテリアライズドビュー
    対象のデータをキャッシュし、実体として保存する。
        ∴こっちのほうが速い。

CREATE MATERIALIZED VIEW(マテリアライズドビューを作成する)
    CREATE MATERIALIZED VIEW
    [IF NOT EXISTS]     :書いてあると既に同名のマテリアライズドビューがあってもエラーにならない
    テーブル名 [(カラム名)] AS 検索処理
    [WITH [NO] DATA];   
        WITH DATA(デフォルト):マテリアライズドビューの作成時にデータを投入する
        WITH NO DATA:データは投入されない。
            データを投入しない場合は、REFRESH MATERIALIZED VIEWコマンドで、
            データが投入されるまでマテリアライズドビューを参照することはできない。

ALTER MATERIALIZED VIEW(マテリアライズドビューの定義を変更するコマンド)
    マテリアライズドビューの所有者のみ実行可能。

    ・所有者を変更する
        ALTER MATERIALIZED VIEW[IF EXISTS]
        マテリアライズドビュー名 OWNER TO
        {新しい所有者名 | CURRENT_USER | SESSION_USER};
            CURRENT_USER:コマンドを実行しているユーザ名
            SESSION_USER:セッションを所有しているユーザ名

    ・マテリアライズドビューのカラム名を変更する場合
        ALTER MATERIALIZED VIEW [IF EXISTS]
        マテリアライズドビュー名
        RENAME[COLUMN] カラム名 TO 新しいカラム名;

    ・マテリアライズドビューの名称を変更する
        ALTER MATERIALIZED VIEW[IF EXISTS]
        マテリアライズドビュー名
        RENAME TO 新しいマテリアライズドビュー名;

        IF EXISTS:指定した名前のマテリアライズドビューが作成されていなくてもエラーにならない

    ・DROP MATERIALIZED VIEW(マテリアライズドビューを削除する)
        マテリアライズドビューの所有者のみ実行可能。
        DROP MATERIALIZED VIEW[IF EXISTS]
        マテリアライズドビュー名
        [CASCADE | RESTRICT];

        CASCADE
            削除対象のマテリアライズドビューに依存するオブジェクトも削除
        RESTRICT
            削除対象のマテリアライズドビューに依存するオブジェクトがある場合は削除しない。

    ・REFRESH MATERIALIZED VIEW(マテリアライズドビューのデータ更新コマンド)
        データの実体を保存する
            元テーブルが変更された場合は、
            マテリアライズドビュー自体も更新が必要。
                更新はREFRESH MATERIALIZED VIEWコマンドで手動でやる。
                    REFRESH MATERIALIZED VIEW[CONCURRENTLY]
                    マテリアライズドビュー名
                    [WITH][NO] DATA];

                    CONCURRENTLYオプション
                        マテリアライズドビューの更新中もSELECT処理をブロックしない。
                    WITH DATA(デフォルト)
                        マテリアライズドビューの更新後にデータ投入
                    WITH NO DATA
                        データ投入されない
                            ※データ投入されるまでマテリアライズドビューは見られない。
                            
DROP MATERIALIZED VIEW
REFRESH MATERIALIZED VIEW

--------------------------------------------------------------
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'FUNCTION | PROCEDURE(Ver11～)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ユーザによる関数の作成、呼び出しが可能。

CREATE FUNCTION 
    CREATE[OR REPLACE] FUNCTION
        関数名([引数の型]) RETURNS [SETOF] 戻り値の型
        AS $$ 処理内容 $$ LANGUAGE 使用言語 [引数NULLの挙動][実行権限];

    Ver11～
    CREATE [OR REPLACE] PROCEDURE
        プロシージャ名([引数モード] [引数の型])
        AS $$ 処理内容 $$ LANGUAGE 使用言語 [実行権限];

        【PROCEDUREオプション：引数モード】
            IN(デフォルト)
                プロシージャに渡す引数の方を指定する

            INOUT
                プロシージャに渡す引数の型と、戻り値の方を指定する
                プロシージャは戻り値の無い関数を指すが、
                INOUTオプションを指定すると戻り値ありにすることもできる。

        【オプション：共通】
            ◎使用言語
                SQL(デフォルト)
                    関数の処理をSQLで記載する
                PL/pgSQL(デフォルトで使用可能)
                    関数の処理をPL/pgSQL(SQLに繰り返しや条件分岐などの制御構造を加えた言語)
                    で記載する

                    PL/pgSQLの構造
                        DECLARE
                            変数宣言
                        BEGIN
                            関数の処理
                        END;
                C
                    関数の処理をC言語で記述。

            ◎引数NULLの挙動(FUNCTIONだけ)
                CALLED ON NULL INPUT(デフォルト)
                    引数の一部にNULLが含まれていても関数の処理を行う
                
                RETURNS NULL ON NULL INPUTもしくはSTRICT
                    引数の一部にNULLが含まれている場合は、
                    関数の処理を行わずにNULLを返す。

            ◎実行権限(共通)
                SECURITY INVOKER(デフォルト)
                    呼び出したユーザの権限で関数を実行する。

                SECURITY DEFINER
                    作成したユーザの権限で関数を実行する。
    例：
        CREATE OF REPLACE FUNCTION
            sample_func(INTEGER)
            RETURN SETOF VARCHER(20) AS $$
            SELECT item_name FROM sample WHERE price > $1;
            $$ LANGUAGE SQL SECURITY DEFINER;

        sample_func(INTEGER)を作成する(引数の型はINTEGER型)
        戻り値はVARCHAR型(20)で、SET OFがあるため戻り値が複数ある場合は複数件返される
        処理の内容はsampleテーブルからitem_nameをpriceが引数1よりも大きいものを取得
        SQLで言語記述し、権限は関数作成者で実行する
        
        同じsample_func(INTEGER)が定義されている場合は置き換えられる
        sample_func(TEXT)が存在し、sample_func(INTEGER)を定義しても
        別の関数と見做され定義できる

ALTER FUNCTION(関数の定義を変更する)
    関数に対する所有者の変更はスーパーユーザのみ。

        書式
            関数の内容を変更する
                ALTER FUNCTION 関数名([引数]) 内容変更;
            
            関数の名称を変更する
                ALTER FUNCTION 関数名([引数]) RENAME TO 新しい関数名;

            関数の所有者を変更する場合
                ALTER FUNCTION 関数名([引数]) OWNER TO 新しい所有者名;

DROP FUNCTION
    削除
        書式
            DROP FUNCTION 関数名([引数];)
                ※引数の方も付けていないと別の方の引数のFUNCTIONと区別ができなくなるから

PRODECUREとFUNCTIONの違い
    CREATE PROCEDURE
        RETURNS句なし、実行はCALLコマンド
    CREATE FUNCTION
        RETURNS句あり、実行はSELECTコマンドを使用

    ALTER PROCEDURE
        プロシージャの内容を変更する場合
            ALTER PROCEDURE プロシージャ名([引数]) 変更内容;

        プロシージャの内容を変更する場合
            ALTER PROCEDURE プロシージャ名([引数]) RENAME TO 新しいプロシージャ名;

        プロシージャの内容を変更する場合
            ALTER PROCEDURE プロシージャ名([引数]) OWNER TO 新しい所有者名;

    DROP PROCEDURE
        DROP PROCEDURE プロシージャ名([引数]);

問題から
    CREATE FUNCTION sample_func(TEXT) RETURNS BOOLEAN AS $$
        TEXT型の引数を持ち、BOOLEAN型を返すsample_func()関数が定義

    DECLARE(ディクレアー：宣言する)
    　　x ALIAS FOR $1;                     変数
    　　result BOOLEAN := FALSE;        変数
    BEGIN
    　　IF x IS NOT NULL THEN       処理
    　　　　result = TRUE;
    　　END IF;
    RETURN result;
    END
    $$ LANGUAGE plpgsql CALLED ON NULL INPUT;
        ※CALLED ON NULL INPUT
            引数にNULLが渡された場合も関数を呼び出して処理を行う。
        ※RETURNS NULL ON NULL INPUT | STRICT
            引数の一部にNULLが含まれている場合は、関数の処理を行わずにNULLを返す。

    SELECT sample_func('test');
        を実行すると、TRUEが返される
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'PREPARE文(プリペアド文)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
PostgreSQLでSQLを実行する
    1.SQLの書き換えが指定されている場合は書き換え処理が行われる。
        SQL文の書き換えは、
            関数やルール
            プリペアド文(引数を渡すと指定したSQL分に置き換える定義)
                を使用することによって指定される。
    2.SQL文の構造を解析し、実行計画(SQL文をどのような処理によって実行するか定めたもの)を作成

SQLの実行毎に上記の処理が行われるが、プリペアド文を使用すると指定した、、、
    問い合わせの書き換え
    構文の解析
    実行計画の作成
        が一度実行するだけで済む
            ∴性能の向上が図れる。

PREPARE(プリペアド文を作る)
    PREPARE プリペアド文の名称 [(引数のデータ型[, 引数のデータ型...])] AS 問い合わせ;
        引数を問い合わせ(SQL)で使用するには($n)で表す。
            問い合わせには、SELECT・INSERT・UPDATE・DELETE・VALUES文を設定できる。

EXECUTE(プリペアド文を実行する)
    EXECUTE プリペアド文の名称[(引数[, 引数...])];
        プリペアド文を実行するコマンド。
            実行時には、PREPAREコマンドでプリペアド文が作成されている必要がある。

DEALLOCATE(プリペアド文を削除する)
    DEALLOCATE[PREPARE]{プリペアド文の名称[(引数[, 引数...])] | ALL};
        オプションでALLを設定すると、全てのプリペアド文が削除される。
    
問題より：
    PREPARE sample_prepare (VARCHAR) AS                 ここはプリペアド文の名前
    SELECT member_info.name address_info.address     問い合わせ
    FROM member_info, address_info
    WHERE member_info.addressId = address_info.addressId
    AND address_info.address = $1;

    member_infoテーブル
    address_infoテーブル
        から、addressIdカラムの値が一致し、かつaddressカラムの値が引数の値と
        等しいデータを取得するプリペアド文。

問題より
    EXECUTE sample_prepare('東京都');
        問題のSQL文では。「address」カラムの値が「東京都」であるデータを取得している。

    EXECUTE プリペアド文の名称[(引数[, 引数...])];

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'TRIGGER
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
特定のテーブルへ更新処理が行われたタイミング
    指定した関数の呼び出しを定義することができる(トリガー)

    書式
        CREATE TRIGGER トリガー名 タイミング イベント ON テーブル名 [影響範囲] _
        EXECUTE PROCEDURE 関数名([引数]);

            【影響範囲のオプション】
            FOR　[EACH]　ROW              対象テーブルの行ごとの更新に対してトリガー実行
            FOR　[EACH]　STATEMENT    足し法テーブルのSQLごとの更新に対してトリガー実行(省略しても各処理の前になる／デフォルト)

        ※イベントを設定する場合にはORで接続する
        ※テーブルの行ごとの更新ではなく、処理(SQL)ごとの更新に対して実行する場合は、
        　影響範囲にFOR EACH STATEMENTを指定するか、オプションを省略する。

    例①：
        CREATE TRIGGER sample_trg BEFORE INSERT OR UPDATE OR DELETE
            ON sample EXECUTE PROCEDURE log_write();

    オプション
        ◎タイミング
            BEFORE
                指定したイベントの実行前にトリガー(関数)を実行する。
                    トリガーがNULLを返した場合はイベントを実行せずに正常終了する。
            AFTER
                指定したイベントの実行後にトリガーを実行

        ◎イベント
            INSERT・UPDATE・DELETE・TRUNCATE
                対象テーブルに対して上記各処理が行われた場合にトリガーを実行。

        ◎影響範囲
            FOR[EACH] ROW　行ごと
            FOR[EACH] STATEMENT(デフォルト)　SQLごと


    ALTER TRIGGER
        トリガーの定義を変更するコマンド。
            トリガーの名称のみ変更できる。
                トリガーが定義されているテーブルの所有者のみ実行可能。

    書式
        ALTER TRIGGER トリガー名 ON テーブル名 RENAME TO 新しいトリガー名;

    DROP TRIGGER
        トリガーを削除するコマンド。
            トリガーが定義されているテーブルの所有者のみ実行可能。
    
    書式
        DROP TRIGGER トリガー名 ON テーブル名;


'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'SEQUENCE(データの追加時に自動で連番を振ってくれる機能)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
テーブルのデータを一意に特定するための番号を生成したい場合に使用する。
シーケンスの初期値はデフォルトで1。
シーケンスは、マイナス値を取ることも可能だしマイナス値で増分させることも可能。

CREATE SEQUENCE
    CREATE SEQUENCE シーケンス名 [オプション]
    【主なオプション】
        INCREMENT [BY]　増減値(デフォルトは：1)
            シーケンスをいくつずつ増やすか指定する。
            マイナス値(いくつずつ減らすか)も指定可能。

        MINVALUE 最小値
            シーケンスの最小値を指定する。
            指定しない場合のデフォルト値は昇順であれば1、
            降順であれば-(2の63乗-1)。

        MAXVALUE 最大値
            シーケンスの最大値を指定。
            指定しない場合のデフォルト値は昇順であれば2の63乗-1、
            降順であれば-1。

        START [WITH] 初期値(デフォルト：１)
            シーケンスをいくつから始めるかを指定する。
            マイナス値も指定可能。

        CACHE キャッシュ数
            メモリに格納できるシーケンス番号の量を指定する。
            検索処理の高速化に使用できる。

        NO CYCLE
            シーケンスが上限または下限に到達した場合、エラーになるように指定する。

例：
CREATE SEQUENCE sample_seq CACHE 5 NO CYCLE;
    sample_seq シーケンスを作成している。

    オプションで、メモリに格納できるシーケンス番号の量が5である。
    シーケンスが限界値に達した時はエラーになるように設定されている。
    増減値は指定がないため、1ずつ層化する。

SELECT setval('sample_seq' , 100);
    採番する値を100に設定している。

SELECT currval('sample_seq');と実行すると100が帰る
SELECT nextval('sample_seq');を実行すると101が取得される。

ALTER SEQUENCE
    シーケンスの定義を変更するコマンド。
    シーケンスの所有者のみが実行できる。
        書式
            シーケンスの内容を変更する場合
            ALTER SEQUENCE シーケンス名 オプション;

            問題から：
                sample_seqシーケンスを増減値-5, 最小値100, 初期値1000に変更
                ALTER SEQUENCE sample_seq
                INCREMENT BY -5 
                MINVALUE 100
                START 1000;

            シーケンスの所有者を変更する場合
            ALTER SEQUENCE OWNER TO 新しい所有者名;

            シーケンスの名称を変更する場合
            ALTER SEQUENCE シーケンス名 RENAME TO 新しいシーケンス名;

            ※主なオプションはCREATE SEQUENCEコマンドと同様。

DROP SEQUENCE
    シーケンスを削除するコマンド。
    
    書式：
        DROP SEQUENCE シーケンス名;

    '-------------------------------------------------
    'シーケンス操作関数
    '-------------------------------------------------
    currval('シーケンス名')
        対象シーケンスの現在値を返す
    nextval('シーケンス名')
        シーケンスを進め、次に採番される値を返す
    setval('シーケンス名' , 'シーケンス値')
        次に採番される値を指定する


    ※シーケンス初期作成後、nextval()関数を呼び出す前にcurrval()関数を呼び出すとエラーになる。
    ※nextval()関数で一度進められたシーケンス値は、ロールバックしてももとに戻らない。
    
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'CURSOR
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
SELECT文の結果を、LIMITを使用せずに任意の場所から必要な件数分取り出す
取り出した行の更新・削除を行う場合にカーソルを使う

    書式：DECLARE CURSORはカーソルを作成するコマンド
        DECLARE カーソル名 [オプション1] CURSOR [オプション2] FOR データを返す問い合わせ;

    問題：
        DECLARE sample_cursor NO SCROLL CURSOR FOR SELECT * FROM sample;
            データの順方向にカーソルを動かせる、逆方向はエラーになる、トランザクション内でのみ使用。
    【オプション1】
        INSENSITIVE(デフォルト)
            カーソルから取得したデータが、取得元テーブルの更新に影響を受けない

        SCROLL(デフォルト)
            データの順方向・逆方向のどちらにも、カーソルを動かせるように指定する

        NO SCROLL
            データの順方向にカーソルを動かせるように指定する
            逆方向に動かそうとするとエラーになる

    【オプション2】
        WITH HOLD
            トランザクションがコミットされた後もカーソルを使用できるようにする

        WITHOUT HOLD(デフォルト)
            トランザクション内でのみカーソルを使用できるようにする

    例／問題文より
    BEGIN;
        DECLARE sample_cursor カーソル名
        SCROLL オプション1
        CURSOR
        FOR SELECT no
        FROM sample
        ORDER BY groupNo, no;

    元のテーブル
    no             name     groupNo
    1               鈴木            1
    2               田中            3
    3               渡辺            3
    4               石原            4
    5               青木            3
    6               山田            2
    7               東山            5

    上記のsqlを実行後
        sampleテーブルのデータをgroupNo,noの昇順で並べ替えたものから、
        noカラムの値を取得するカーソルを作成している。

    ↓ここがカーソル   
    no             name     groupNo
    1               鈴木            1
    6               山田            2
    2               田中            3
    3               渡辺            3
    5               青木            3
    4               石原            4
    7               東山            5
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'MOVE：カーソルの移動のみを行い、データは取得しない
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
MOVE FORWARD 3 FROM sample_cursor;
    MOVEはカーソルの移動のみを行う。
        書式
            MOVE [オプション[FROM]] カーソル名;
                SQL文はオプションにFORWARD 3を設定しているため、
                カーソルは順方向に3つ進められる。
                ∴3件目のデータに到着。"2"。

        【オプション】
        FETCHと全く同じ。
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'FETCH：カーソルの移動と同時にデータを取得するコマンド
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
FETCH
    BACKWARD ALL    オプション
FROM sample_cursor;
COMMIT;

    FETCHはカーソルの移動と同時にデータを取得するコマンド。
        書式
            FETCH [オプション [FROM]] カーソル名;
                FETCH BACKWARD ALL FROM sample_cursor;
                    SQL文はオプションにBACKWARD ALLを設定している
                        ∴カーソルは1つ前のデータから逆方向に終わりまで進む
                            ∴対象のデータ(この場合は「no」カラムが6、1のデータ)が取得。

        【オプション】
            FORWARD | NEXT(デフォルト)
                カーソルを順方向に1つすすめる

            BACKWARD | PRIOR
                カーソルを逆方向に1つ進める。

            ALL | FORWARD ALL
                カーソルを、1つ前のデータから逆方向に終わりまで進める。

            BACKWARD ALL
                カーソルを、1つ前のデータから逆方向に終わりまで進める。

            FORWARD カウント数
                カーソルを、1つ次のデータから順方向にカウント数分進める。

            BACKWARD カウント数
                カーソルを、1つ前のデータから逆方向にカウント数分進める。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'INDEX
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
データベースからデータを検索する場合、テーブルサイズが大きくなるにつれて検索範囲が大きくなる
    ∴処理に時間がかかる。
        対策として検索対象のカラムにインデックスを作成することでカラムを索引のように使用する
            ∴検索処理を効率化する方法がある。

特徴：
    ・検索処理を効率化し、性能を上げるために使用される
    ・作成することで必ず性能が向上するという保証はない。
        ∴作成時には注意が必要。
    ・インデックスは未使用であっても整合性が取れるように管理される
        ∴更新処理が遅くなるかも
    ・複数カラムを組み合わせて作成することもできる
    ・主キー制約やユニーク制約を定義すると自動作成
    ・インデックスに使用できるインデックスの種類はB-Tree、GiST、GIN、ハッシュである
    ・インデックスを作成しても、where句などの条件でインデックスの作成されているカラムが使用されていない場合、
    　インデックスは使用されない
    ・データを更新した場合は、自動で管理される(更新？)

管理コマンド：
CREATE INDEX
    インデックスを作成する。
        書式
            CREATE INDEX インデックス名 ON テーブル名 [USING インデックスの種類](カラム名[,カラム名]);
                【作成するインデックスの種類】
                    B-Tree(デフォルト)
                        主に等号や不等号の検索に使用する
                        ソートが必要な処理を高速化できる
                    GiST
                        2次元以上の空間に対する、一致や包括の検索に使用する全文検索を高速化
                    GIN
                        配列などに対する、特定の値の検索に使用する
                        全文検索を高速化できる
                    ハッシュ
                        等号の検索に使用する

        問題から
            次のSQLを効率よく実行できるように、インデックスを作成したい。
            SELECT id, groupName FROM sample WHERE id < 50 AND groupName = '総務部;'
                idとgroupNameに対して検索しているため、インデックスを付けるならその両方につける
        ↑を受けて作成するインデックス
            CREATE INDEX sample_idx ON sample(id, groupName);
                

ALTER INDEX
    インデックスの定義を変更するコマンド。
    ALTER INDEXで変更できるのは、インデックスの名称。

    ※実行時にテーブルロックはかからない。
    ※ALTER INDEXで名称を変更したインデックスもDROP INDEXで削除できる。

DROP INDEX  使えるのはインデックスの所有者のみ
    インデックスを削除する
        書式
            DROP INDEX インデックス名;
        
        問題から
            DROP INDEX member_idx;

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'DOMAIN
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
目的
    複数のテーブルに於いて、同じ制約条件(NULL/NOT NULL/CHECK制約のみ)
    を持つデータ型を使用したい場合に、独自のデータ型を定義することができる。
    
ルール
    データベース内の複数のテーブルで使用可能。
    ドメインを使用する場合、テーブルに対して制約の定義が制限されることはない。
    ドメイン定義の変更はALTERDOMAINを使用する。

構文
    CREATE DOMAIN(ドメインを削除するコマンド)
        書式：
            CREATE DOMAIN ドメイン名
            AS データ型 
            [DEFAULT デフォルト値]
            [[CONSTRAINT 制約名]]制約[, [CONSTRAINT 制約名]制約...]];

        【主なオプション】
        ◎制約
            NULL(デフォルト)
                作成したドメインにNULLを格納できるようにする

            NOT NULL
                作成したドメインにNULLを格納できないようにする

            CHECK(条件式)
                作成したドメインに条件式に一致しないデータを格納できないようにする。
                カラムの値は「VALUE」キーワードで表す。

    ALTER DOMAIN(ドメインの定義を変更するコマンド)
        ドメインの所有者のみ実行可能。

        書式：
            ドメインのデフォルト値を設定する場合
                ALTER DOMAIN ドメイン名 SET DEFAULT デフォルト値;

            ドメインのデフォルト値を削除する場合
                ALTER DOMAIN ドメイン名 DROP DEFAULT;

            ドメインの制約を削除する場合
                ALTER DOMAIN ドメイン名 DROP CONSTRAINT 制約名;
            
            ドメインの所有者を変更する場合
                ALTER DOMAIN ドメイン名 OWNER TO 新しい所有者名;

            ドメインの名称を変更する場合
                ALTER DOMAIN ドメイン名 RENAME TO 新しいドメイン名;
            
    DROP DOMAIN
        DROP DOMAIN ドメイン名;
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
’継承
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
親テーブルの定義を引き継いだテーブルを定義することができる機能のこと。
子テーブルには親テーブルにない定義を追加することも可能。
子テーブルに存在するデータを親テーブルの検索から取得することができる。

構文：
CREATE TABLE テーブル名
(カラム名 データ型[, カラム名 データ型...])
INHERITS(親テーブル名[, 親テーブル名...]);

'#############################
'テーブル結合(JOIN)
'#############################
    SELECT文のFROM句に記載して使用する。
    特定のカラムを、結合条件に指定するカラム(結合キー)に設定する
        値が等しいものを結合。
            INNERJOIN
            OUTERJOIN
            CROSSJOIN
                がある。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'INNER JOIN
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
    対象のテーブルから、結合キーの値が等しいデータのみを取得する。
    NATURALを用いると、名前が同じカラムを全て結合キーに指定する。

    書式：
        テーブル名1 
        [INNER] JOIN テーブル名2
        ON
        テーブル名1.カラム名 = テーブル名2.カラム名
        [AND テーブル名1.カラム名 = テーブル名2.カラム名...]

        テーブル名1
        [INNER] JOIN テーブル名2
        USING (カラム名[, カラム名...])

        テーブル名1
        NATURAL [INNER] JOIN テーブル名2

        結合後の結合キーの出力方式は、結合キーの指定方法によって変わる。
            ON句で指定した場合
                それぞれのテーブルごとに重複して出力
            USINGやNATURALを用いて指定した場合
                1つに纏められてテーブルの一番左に出力
    
    image
    tableA                                  tableB
    no     name        post_id         post_id     post_no
    1       田中          1                         1           1230001        
    2       山田          1                         2           1230002    
    3       内川          3                         3           1230003
    4       渡辺          4                         4           1230004
    5       菊池          5

    join
    no      name        post_id     post_id     post_no
    1           田中        1               1               1230001
    2           山田        1               1               1230001
    3           内川        3               3               1230003
    4           渡辺        4               4               1230004

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'OUTER JOIN(外部結合)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
対象のテーブルから、結合キーの値が等しいデータに加えて、条件の一致しないデータも取得。
NATURALを使うと、名前が同じカラムを全て結合キーに指定する。
条件に一致しなかったデータをどのテーブルから取得するかはLEFT,RIGHT,FULLの中から選択。

    LEFT
        左側のテーブル(書式ではテーブル名1)から条件に一致しないデータを取得
    RIGHT
        右側のテーブル(書式ではテーブル名2)から条件に一致しないデータを取得
    FULL
        両側のテーブル(書式ではテーブル名1,2)から条件に一致しないデータを取得

    書式
        テーブル名1 
        {LEFT | RIGHT | FULL} [OUTER] JOIN テーブル名2
        ON テーブル名1.カラム名 = テーブル名2.カラム名
        [AND テーブル名1.カラム名 = テーブル名2.カラム名...]

        テーブル名1
        {LEFT | RIGHT | FULL} [OUTER] JOIN テーブル名2
        USING(カラム名[, カラム名...])

        テーブル名1 NATURAL
        {LEFT | RIGHT | FULL} [OUTER] JOIN テーブル名2

        ※結合後の結合キーの出力方式はINNER JOINと同様。

        image

        SELECT * FROM tableA LEFT OUTER JOIN tableB USING(post_id);
        tableA                                          tableB
        no          name         post_id         post_id         post_no
        1            田中               1                   1               1230001
        2            山田               1                   2               1230002
        3            内川               3                   3               1230003
        4            渡辺               4                   4               1230004    
        5            菊池               5

        JOIN
        post_id         no          name            post_no
        1                   1               田中            1230001
        1                   2               山田            1230001
        3                   3               内川            1230003
        4                   4               渡辺            1230004
        5                   5               菊池            NULL

        ※↑USINGなので左側に纏められた


'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'CROSSJOIN(直積)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
    対象テーブルの全データの組み合わせを取得。
    結合キーの指定は不要。

    書式
        テーブル名1 CROSS JOIN テーブル名2
        テーブル名1, テーブル名2

    問題から
        SELECT * FROM menber CROSS JOIN department;
        SELECT * FROM member, department;
            ↑2番目のほうが理解できていないので注意。

image
    id              size
    0001           23.5
    0001            24.5
    0003            24

    id              size
    0001            24.5
    0002            23
    0005            22.5

    この場合、直積(CROSSJOIN)すると
    0001        23.5    0001    24.5
    0001        23.5    0002    23
    0001        23.5      0005    22.5
    /
    /
    /

    で、合計9つのレコードになる。
        ∴全部の組み合わせが掛け算になって出てくる

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'UNION(和結合)：重複を除く全てのデータ
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
例：
    SELECT * FROM projectA UNION SELECT * FROM projectB;
    projectBテーブルとprojectAテーブルのデータを重複を排除して抽出する

    projectA        projectB    UNION
    A                   C               C
    A                   C               D
    B                   C               A
    C                   D               B
    C

    UNION ALLすると：重複を覗かない全てのデータ
    projectA        projectB    UNION　ALL
    A                   C               A
    A                   C               A
    B                   C               B
    C                   D               C
    C                                    C
                                        　C
                                        　C
                                        　C
                                        　D

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'EXCEPT文(差集合)：projectAテーブルからprojectBテーブルを覗いたデータ
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
例①：
    SELECT * FROM teamA EXCEPT ALL SELECT * FROM teamB
        teamAテーブルのデータから、teamBテーブルに存在するデータを引いた残りを意味。
            ※ALLが指定されていると、重複データは省かれない。

        teamA   teamB       ↑のSQLを実行すると6年生、6年生が出力される。
        2年生       5年生
        2年生       2年生
        6年生       2年生
        6年生

SELECT * FROM projectA EXCEPT SELECT * FROM projectB;
    projectA        projectB    EXCEPT
    A                   C               A
    A                   C               B
    B                   C               
    C                   D               
    C

SELECT * FROM projectA EXCEPT ALL SELECT * FROM projectB;
    projectA        projectB    EXCEPT ALL
    A                   C               A
    A                   C               A
    B                   C               B
    C                   D               
    C
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'INTERSECT文(積集合)：共通するデータが返される
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
SELECT * FROM projectA INTERSECT SELECT * FROM projectB;
    ALLが指定していない場合は自動でDISTINCT
    ALLが指定されている場合は全部取得

    projectA        projectB    EXCEPT
    A                   C               C
    A                   C               
    B                   C               
    C                   D               
    C
'#############################
'制約
'#############################
①主キー(プライマリキー)制約
    重複する値やNULL値を格納させない制約
    テーブルのデータを特定したい場合に使用する。
    テーブル毎に1つだけ設定が可能
    制約の対象にはインデックスが自動で作成される
    「PRIMARY KEY」キーワードを使用する

②ユニーク(一意)制約
    重複する値を格納させない制約
    制約の対象にはインデックスが自動で作成される
    「UNIQUE」キーワードを使用する

③NOT NULL制約
    NULL値を格納させない制約
    カラムの値を常に有効値にしたい場合に用いる
    「NOT NULL」キーワードを使用する

④外部キー(参照整合性)制約
    参照テーブルに存在しない値を格納させない制約
    参照先テーブルとの整合性を担保したい場合に使用する
    「REFERENCES」,「FOREIGN KEY」キーワードを使用する

⑤チェック(検査)制約
    ユーザが定義した条件に一致しない値を格納させない制約
    「CHECK」キーワードを使用する
'#############################
'データ型
'#############################
数値型
    整数や実数を格納するデータ型(浮動小数点も？)
文字列型
    文字列を格納するデータ型
バイナリ列データ型
    バイナリ列を格納する
論理値型
    論理値を格納するデータ型
日付・時刻型
    日付や時刻を格納するデータ型
連番型
    連番値を格納するデータ型
OID型
    オブジェクトを識別するためのID値を格納するデータ型
配列型
    複数の値を格納するデータ型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'数値型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
    【整数】
    SMALLINT(2バイト)
        16bitの符号付き整数を格納する
            -32768から+32767までの値を扱う
    INTEGER/INT(4バイト)
        32bitの符号付き整数を格納する
            -2147483648～+2147483647までの値を扱う
    BIGINT(8バイト)
        64bitの符号付き整数を格納する
            -9223372036854775808から
            +9223372036854775807までの値を扱う
    【小数】
    REAL(4バイト)
        浮動小数点数を格納する
            最低6桁の精度を持つ
    DOUBLE PRECISION(8バイト)
        浮動小数点を格納する
        最低15桁の精度を持つ

    【実数】
    NUMERIC DECIMAL(可変長)
        実数を格納する
        最大1000桁までの任意の精度を指定できる

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'文字列型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
TEXT型
    上限1GBの可変長文字列を格納
CHARCTER VARYING(n)/VARCHAR(n)型
    nで指定した文字数以下の文字列を格納する
    nを省略した場合はTEXT型同様、上限1GBの可変長文字列となる
CHARCTER(n)/CHAR(n)型
    nで指定した文字数の文字列を格納する
    n桁に満たない場合は、空白文字が設定される

    ※格納指標とした値の文字数が文字数制限のある方の指定以上の場合はエラーとなる。
    ただし、制限を超えている文字が半角空白文字のみの場合は、
    指定文字数まで自動で切り詰められて格納される。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'バイナリ列データ型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
BYTEA型(1または4バイトと実データの長さ)
    可変長のバイナリ列(バイトの連続からなるテキスト以外のデータ)を格納する

    参考：
        ※バイナリ型データは文字列型に格納できない
        ※バイナリ型データは連番型に格納できない
        ※テキストデータは含まれない(バイトの連続からなるテキスト以外のデータを指す)
        ※ロケールによって値の意味が変わることはない(バイト値そのものが処理される)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'論理値型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
BOOLEAN/BOOL型(1バイト)
    真か偽、またはNULLを格納する
        真：'t' 'true' 'y' 'yes' 'on' '1' 'TRUE'
        偽：'f' 'false' 'n' 'no' 'off' '0' 'FALSE'
            ※格納しようとした値が使用できる文字以外の場合はエラーとなる。

判定式(問題)
    SELECT ' ' IS NULL;
    SELECT ' ' IS NOT NULL;
        NULLの判定にはIS NULL演算子・IS NOT NULL演算子を使用する。
        TRUE FALSEを返したければどちらかを使う。

NULLについて
    データベースの連番型以外のどのデータ型にも設定することができる。
    空文字""とは異なり、値がないことを意味する。
    NULLを含むカラムであってもソート対象に指定することはできる。
    NULLに対して「=」や「<>」などの一般的な演算子を用いることはできず、
    用いた場合の結果はNULLとなる。

    判定する時はIS NULLまたはIS NOT NULL。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'DATE型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
DATE型(4バイト)
    時刻なしの日付を格納する
        例：
            2017-01-01
            2017/01/01
            2017-Jan-01
            Jan 01 2017

TIME[WITHOUT TIMEZONE]型(8バイト)
    タイムゾーンなしの時刻を格納する(マイクロ秒まで)
        例：
            14:00:00.000000

TIME WITH TIMEZONE型(12バイト)
    タイムゾーン付きの時刻を格納する(マイクロ秒まで)
        例：
            14:00:00.000000+09

TIMESTAMP型[WITHOUTTIMEZONE](8バイト)
    タイムゾーンなしの時刻と日付を格納する(マイクロ秒まで)
    日付部分の書式はDATE型と同じ書式が使用できる
        2017-01-01 14:00:00.000000

TIMESTAMP WITH TIMEZONE(8バイト)
    タイムゾーン付きの時刻と日付を格納する(マイクロ秒まで表示)
    日付部分の書式はDATE型と同じ書式が使用できる
        2017-01-01 14:00:00.000000+09

INTERVAL(16バイト)
    時間間隔を格納する
        使用できる単位はyear,month,day,hour,minute等
            interval '1 year'
            '1 year' ::interval

格納しようとした値の書式が許容されている形式以外の場合はエラーとなる。

now()関数から減算する場合
    interval関数であれば可能

    例：
        SELECT now() - '3 month'::interval;
        SELECT now() - interval '3 month';

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'連番型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
SERIAL型(4バイト)
    自動採番のINTEGER型のデータを格納する
        -2147483648～+2147483647までの値を扱う

BIGSERIAL型(8バイト)
    自動採番のBIGINT型のデータを格納する
        -9223372036854775808から
        +9223372036854775807までの値を扱う

格納しようとした値がNULLの場合はエラーとなる。
連番型のカラムを作成すると、1から順に正の値を取るシーケンスが同時に作成される。    
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'OID型
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
OID型(4バイト)
    オブジェクトを識別するためのid値を格納する
    テーブルやインデックス、関数などに対して使用。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'配列型(特殊？)
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
※全データ型に対して使用できる。
※1番めの要素はa[1]となる。
※NULLも格納できる。
※要素数に制限はない。

配列型を操作する書式は以下の通り。

・配列の宣言を行う
    例：
        sampleテーブルにVARCHAR型の配列型「name」を宣言
            CREATE TABLE samlple (name VARCHAR[]);
                宣言する際には特に最大値を決める必要はない

・配列の挿入を行う
    例：
        sampleテーブルのVARCHAR型の配列型「name」に、
        「佐藤」、「田中」、「今井」を挿入
            INSERT INTO samPle VALUES('{"佐藤", "田中", "今井"}');

・配列の検索を行う場合
    例：
        sampleテーブルから、VARCHAR型の配列型「name」の3番めの要素を取得
        SELECT name[3] FROM sample;

    例：
        sampleテーブルのVARCHAR型の配列型「name」において、
        1番目の要素が「鈴木」の配列を取得
        SELECT * FROM sample WHERE name[1] ='鈴木';

・配列の更新を行う場合
    例：
        sampleテーブルのVARCHAR型の配列型「name」において、
        1番めの要素が「鈴木」の配列に対して、2番目の要素を「山田」に変更
        UPDATE sample SET name[2] = '山田' WHERE name[1] = '鈴木';

    例：
        sampleテーブルのVARCHAR型の配列型「name」において、
        1番目の要素が「鈴木」の配列に対し、
        末尾に「渡辺」を挿入
        UPDATE sample SET name[4] = '渡辺' WHERE name[1] = '鈴木';
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'ラージオブジェクト
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
巨大なバイナリ・テキストデータを格納できる機能。
扱うことのできるデータサイズ上限は4TB。
格納先はシステムカタログの「pg_largeobject」テーブル
    ユーザテーブルに格納されたOIDによって紐付けられる。

ラージオブジェクトを格納すると、そのOIDが返される。
ラージオブジェクトの格納と取得には\lo_import, \lo_exportコマンドを使用する。

    ※ラージオブジェクトに格納するファイルデータは、Postgres権限でアクセスできる
    　ディレクトリ配下に置く必要がある。

'#############################
'DML文
'#############################
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'INSERT文
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
書式
    INSERT INTO テーブル名 [(カラム名[, カラム名...])] VALUES (値[, 値...]);
    INSERT INTO テーブル名 [(カラム名[, カラム名...])] SELECT文;
        INSERTコマンドで省略したカラム／
            デフォルト値が含まれている場合にはデフォルト値、
            定義されていない場合はNULLが挿入される。
                ∴カラムにNULLを挿入したい場合はカラムを省略するかNULLを代入する

INSERT INTO sample1 VALUES(5, '佐藤');
INSERT INTO sample1 (no , name) VALUES(5, '佐藤');

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'(副問合せの結果)演算子
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
【副問合せの結果が1件以下】
=：副問合せの結果と一致するかどうか
<：副問合せの結果より小さいかどうか
>：副問合せの結果より大きいかどうか
<=：副問合せの結果以下かどうか
>=：副問合せの結果以上かどうか
<> | !=：副問合せの結果と一致しないかどうか

【副問合せの結果が1件以上】
IN：副問合せの結果に一致するものがあるかどうか(副問合せ部分を固定値に変更可能)
NOT IN：副問合せの結果全てと一致しないかどうか(副問合せ部分を固定値に変更可能)
EXISTS：副問合せの結果が存在するかどうか
NOT EXISTS：副問合せの結果が存在しないかどうか
    注意：
        EXISTSは副問合せの結果が存在するかどうかを判定する。
        NOT EXISTSは副問合せの結果が存在しないかどうかを判定する。
            副問合せに関する条件が指定されるかどうかで、取得内容が変わる。

                対象テーブルに関する条件がない
                    判定が真の場合はテーブルの全データを取得する。
                        例：
                            SELECT * FROM animal WHERE EXISTS(SELECT * FROM zooB WHERE num = 3);
                            この場合は全データを取得する(テーブルに対する条件が存在しない)
                    判定が偽の場合はデータを全く取得しない。
                        例：
                            SELECT * FROM animal WHERE EXISTS(SELECT * FROM zooB WHERE num = 3);
                            この場合は全くデータを取得しない(テーブルに対する条件が存在しない)

                対象テーブルに関する条件がある
                    EXISTSの場合はテーブルから条件に一致するデータのみを取得する
                        例：
                            SELECT * FROM animal WHERE EXISTS(SELECT * FROM zooB WHERE zooB.name = animal.name);
                            対象テーブルに対する条件があるため、合致したデータが取得される
                    NOT EXISTSの場合はテーブルから条件に一致しないデータのみを取得
                        例：
                            SELECT * FROM animal WHERE NOT EXISTS(SELECT * FROM zooB WHERE zooB.name = animal.name);
                            対象テーブルに対する条件があるため、合致しないデータが取得される
ANY：副問合せの結果のいずれかと一致するかどうか
=ANY | =SOME：副問合せの結果のいずれかと一致するかどうか
<>ANY | <>SOME：副問合せの結果のいずれかと一致しないかどうか
=ALL：副問合せの結果全てと一致するかどうか
<>ALL：副問合せの結果全てと一致しないかどうか

’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'副問合せ
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
FROM句
    書式：
        SELECT カラム名 FROM 副問合せ [AS] 別名[WHERE 条件];

    FROM句で指定するデータの取得先として、テーブルの代わりに副問合せの結果を指定。
        副問合せ部分には別名を指定する必要がある。
            複数の副問合せで同じカラム名を取得する際に、
            SELECT句のカラム名に対象テーブルを明記しない場合はエラーになる。

    err例①：
        SELECT * FROM (SELECT name FROM zooA);
            別名がないのでエラーzooA)の後に[AS]fooとか入れる必要がある

    err例②：
        SELECT name FROM (SELECT name FROM zooA)listA, (SELECT name FROM zooB) listB;
            複数の副問合せがあるが、どのテーブル由来かを指定していないためエラーになる

SELECT句での副問合せ
    書式：
        SELECT 副問合せ;
            正常：
                SELECT(SELECT name FROM zooA WHERE num > 10);
                    副問合せの結果、返されるカラムが1つなのでOK
            err：
                SELECT (SELECT * FROM zooA WHERE num > 10);
                    副問合せの結果、返されるカラムが複数あるのでエラー

・SELECT句で使用する副問合せの結果が複数カラムまたは2件以上の場合はエラー。
・FROM句で使用する副問合せに対して、別名を指定しない場合はエラー。
・複数の副問合せで同じカラム名を取得する際に、
　SELECT句のカラム名に対象テーブルを明記しない場合もエラー。
・WHERE句で使用する副問合せに対し、件数結果に対して適切な演算子を使用しない場合はエラー。

※WHERE句の副問合せにANYやNOT INを使用した場合は、
副問合せの結果件数は何件でも対応可能。

※SELECT句で使用する副問合せの結果は、1件以下である必要がある。

’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'DISTINCT
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
書式：
    SELECT DISTINCT [ON (対象カラム名[, 対象カラム名...])] SELECT対象カラム名[, SELECT対象カラム名...]

    DISTINCTはSELECT句の直後に記載。
    「ON (対象カラム名[, 対象カラム名...])」を省略すると、SELECT対象カラムを重複除去の対象とする。
    groupNoカラムの重複を除くには以下の2つがある。

    1.groupNoをON句に指定する
        SELECT DISTINCT ON (groupNo) groupNo FROM sample WHERE sex = '男';

    2.「ON(対象カラム名[, 対象カラム名...])」を省略してgroupNoをSELECT対象カラムに指定する
        SELECT DISTINCT groupNo FROM sample WHERE sex = '男';
    
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'LIMIT,OFFSET
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
SELECT文で取得する検索結果の件数や、取得するデータ範囲を指定する際に使用。
WHERE・FROM・ORDER BY句の後に記載する。

書式：
    LIMIT 取得件数の上限 [OFFSET 結果の取得時にスキップする件数]

例：
    sampleテーブルに5件入っているとすると...
    SELECT * FROM sample ORDER BY no LIMIT 4 OFFSET 1;
        2件目から4件分のレコードを取得する

’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'CASE文(IF文みたいなもん)
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
SQL文中で異なる処理を行いたい場合に用いる。
    書式
        CASE WHEN 条件1 THEN 条件1に一致した場合の結果
            [WHEN 条件2 THEN 条件2に一致した場合の結果...]
            [ELSE どの条件にも一致しなかった場合の結果]
        END

    問題から：
        SELECT id 
        FROM sample
        WHERE 
            CASE WHEN age < 30 THEN FALSE
            ELSE TRUE 
        END;
        sampleテーブルからageが30より小さいものをfalseとして、
        ageが31より大きかったらtrueにする

’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'パーティショニング
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
テーブルなどのデータを複数のまとまりに分割する機能のこと。
    一つのテーブルを物理的に分割するため、データへの処理パフォーマンスを向上できる。

    例：論理的には一つのテーブルとして扱われる
        検索時にパーティションを限定する
            アクセスするデータ数が減少する
            処理速度が速くなる
        データ削除時
            DELETEするのではなく、対象パーティションをDROP TABLEする
                ∴高速で削除

    AテーブルをA1～A4テーブルに分割する
        ユーザは、分割されていることは意識せず、Aテーブルに処理をする
            勝手にA1～A4に処理をしにいく
            DROPするときはA4とかを指定すれば勝手にDROPされる
        
Ver10から宣言パーティションという方式が実装されたため、
より簡単に実現できるようになった。
    
    方法
        リスト・パーティショニング
            値によって分割する方法。
            値でアクセス範囲を絞りたいときに使用。
                ↓部活カラムの値でパーティショニング

                生徒ID      部活                        1生徒ID      部活
                A0001       野球部                      A0001       野球部
                A0002       野球部                      A0002       野球部
                A0003       テニス部
                A0004       バレー部
                                                            2生徒ID      部活
                                                                A0003       テニス部

                                                            3生徒ID      部活
                                                                A0004       バレー部

            書式：
                [親テーブル]　
                CREATE TABLE 親テーブル名(親テーブル定義)
                PATITION BY LIST(キーとなるカラム名);

                [子テーブル]
                CREATE TABLE 子テーブル名
                PARTITION OF 親テーブル名
                FOR VALUES IN (分割するカラムの値);

            書式：ALTER TABLE {ATTACH | DETACH} PARTITION
                パーティションを切り離すまたは組み込むコマンド

                パーティションを組み込む
                    ALTER TABLE 親テーブル名
                    ATTACH PARTITION 子テーブル名
                    FOR VALUES IN('分割するカラムの値');

                パーティションを切り離す
                    ALTER TABLE 親テーブル名 DETACH PARTITION 子テーブル名;


        レンジ・パーティショニング
            値の範囲で分割する方法。
                ある値の古いデータから削除していきたい場合などに使用する。
↓                                                                   2017-01-01～2017-12-31
                ユーザ          内容            日付             ユーザ          内容            日付
                user001      SELECT     2017-11-24   user001      SELECT     2017-11-24
                user002      DELETE     2017-11-30   user002      DELETE     2017-11-30
                user002      INSERT     2017-12-19   user002      INSERT     2017-12-19
                user004      SELECT     2018-01-23
                                                                      2018-01-01～2018-12-31
                                                                      ユーザ          内容            日付
                                                                      user004       SELECT      2018-01-23
            書式：CREATE TABLE PARTITION {BY | OF}
                [親テーブル]
                CREATE TABLE 親テーブル名 (親テーブル定義)
                PARTITION BY RANGE(キーとなるカラム名);

                [子テーブル]
                CREATE TABLE 子テーブル名
                PARTITION OF 親テーブル名
                FOR VALUES FROM(分割するカラムの開始値)
                TO(分割するカラムの終了値);

            書式：ALTER TABLE {ATTACH | DETACH} PARTITION
                パーティションを切り離すまたは組み込むコマンド

                パーティションを組み込む
                    ALTER TABLE 親テーブル名
                    ATTACH PARTITION 子テーブル名
                    FOR VALUES IN('分割するカラムの値')

                パーティションを切り離す
                    ALTER TABLE 親テーブル名 DETACH PARTITION 子テーブル名;

        ハッシュ・パーティショニング
            ハッシュ値を使用して、ほぼ均等にデータを分割する方法(問題に均等！って書いてある)
            INSERT処理の頻度が高く、INSERT先を分散することで競合を防ぐ場合などに使用。

            三等分
            商品ID      商品名                  商品ID      商品名
            S01         大皿                        S01         大皿
            S02         醤油皿                      S04         湯呑
            S03         ご飯茶碗
            S04         湯呑                   商品ID      商品名           
            S05         深皿                    S02             醤油皿
            S06         取皿                    S05             深皿

                                                  商品ID      商品名
                                                    S03             ご飯茶碗
                                                    S06             取皿

            書式：
                [親テーブル]
                CREATE TABLE 親テーブル名(親テーブル定義)
                PARTITION BY HASH(キーとなるカラム名);

                [子テーブル]
                CREATE TABLE 子テーブル名
                PARTITION OF 親テーブル名 
                FOR VALUES WITH(MODULUS 分割する数, REMAINDER 分割する数より小さな整数値);

            書式：ALTER TABLE {ATTACH | DETACH} PARTITION
                パーティションを切り離すまたは組み込むコマンド

                パーティションを組み込む
                    ALTER TABLE 親テーブル名
                    ATTACH PARTITION 子テーブル名
                    FOR VALUES WITH(MODULUS 分割する数, REMINDER 分割する数より小さな整数値);

                パーティションを切り離す
                    ALTER TABLE 親テーブル名 DETACH PARTITION 子テーブル名;
                        パーテーションを切り離すと、切り離したテーブルは個別のテーブルとして扱われるようになる。
                        切り離した直後から、親テーブルの検索結果には出現しないようになる。

                        ALTER TABLE club DETACH PARTITION volleyball;
                        clubテーブルからvolleyballテーブルを切り離している。

                        ALTER TABLE club ATTACH PARTITION volleyball
                        FOR VALUES IN('バレー部');

                        clubテーブルにvolleyballテーブルの('バレー部')という値を入れろとしている。
                        親テーブルの検索処理に取得されるようになる。


’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
テーブルスペース(テーブル空間)
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
データベースオブジェクトを格納する領域のこと。
    データベースオブジェクトは、必ずテーブルスペースに格納される。
    PostgreSQLでは、デフォルトテーブルスペースが「$PGDATA/base」となっている。
        指定しなければ「$PGDATA/base」に作成される。

テーブルスペースを指定する場合は、データベースオブジェクトの作成時に行う。
データベースオブジェクトの変更時にも指定が可能。

    メリット：
        複数のテーブルスペースを使用することで、
            データベースクラスタの容量が不足してきた際に対応できること
            データベースオブジェクトの使用頻度などに応じてハードディスクを割り当てられること

CREATE TABLESPACE(テーブルスペースを作成する)
    書式：
        CREATE TABLESPACE
        テーブルスペース名 [OWNER{所有者名 | CURRENT_USER | SESSION_USER}]
        LOCATION 'テーブルスペースのパス';

            CURRENT_USER:コマンドを実行しているユーザ名
            SESSION_USER:セッションを所有しているユーザ名

                LOCATIONで指定するディレクトリ(テーブルスペースのパス)は、
                事前に作成しておく必要がある。

ALTER TABLESPACE(テーブルスペースの定義を変更するコマンド)
    テーブルスペースの所有者のみ実行可能。

    名称変更
        書式：
            ALTER TABLESPACE テーブルスペース名 RENAME TO 新しいテーブルスペース名;

    所有者変更
        書式：
            ALTER TABLESPACE テーブルスペース名 OWNER TO
            {新しい所有者名 | CURRENT_USER | SESSION_USER};

DROP TABLESPACE(テーブルスペースを削除するコマンド)
    テーブルスペースの所有者のみ実行可能
        書式：
            DROP TABLESPACE[IF EXISTS] テーブルスペース;
                IF EXISTSオプションを指定すると、
                指定した名前のテーブルスペースが作成されていなくてもエラーにならない。

’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
問題から出てきた知らない知識達
’＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
    INSERT INTO member SELECT 'Y0099' , '2017-03-17', 0, 'f'
        SELECT句に値を直接指定している場合は、SELECT結果として指定した値が取得される

    UPDATE member  SET score = score + 2000 WHERE login;
        WHERE句にboolean型のカラム名を指定した場合は、
        カラムの値が真(この場合はt)であるデータが条件に一致することになる。

↓全部終わったら消す

問題用に残しておく
id          name        age         sex     groupName
1           佐藤           24           女          人事
2           鈴木            30          男          人事    
3           渡辺            19          男          １
4           加藤            28          女          ２
5           山田            34          女          3
6           青木            26          男          2

id          register_date       score       login
p0001   2016-02-12          4000        t
m0002   2013-12-04          3800        f
y0099   2017-03-17          0               f
s0003   2017-05-02          2700            f
s0004   2017-05-14          3500            t

group_info
★group_id(primary key)   group_name(varchar)
1                                     営業部
2                                     技術部
3                                   　総務部

member_info
id(INTEGER PRIMARY KEY)     group_name(varchar)     ★group_id(INTEGER)
1                                           河野                                1
2                                           島田                                3

club
id              name
1               野球部
2               テニス部
3               弓道部
4               野球部
5               サッカー部
6               バレー部
7               卓球部

sample
no      name        groupNo
1       鈴木            1
6       山田            2
2       田中            3
3       渡辺            3
5       青木            3
4       石原            4
7       東山            5

address
id (char,unique)        postnum(char)       address(varchar)
0001                        1111111                 kenn
null                          2222222                 kenn

customer
id(char,primary key) name(varchar)        addressid(char,references address(id)) 
00000001                田中一郎                0001

sample
id              name            age         sex         groupName
1               佐藤                24          女          人事部
2               鈴木                30          男          人事部
3               渡辺                19          男              1部
4               加藤                28          女              2部
5               山田                34          女              3部
6               青木                26          男              2部

employee
id              tel                  groupid             addressid
0001         0801111111     0002                0006
0002         0802222222     0005                0003
0003         0803333333     0001                0017
0004         0804444444     0001                0002
0005         0805555555     0004                0005

groupNo     no      name        tel     groupName   boss

student_id      subj        score
s1000312        数学        0
s2000637        国語        45
s2000630        生物        82
s3000227        化学        100
s2000314        歴史        22

c2(char(1))     c3(integer)

sample1
no(integer)      name(varchar(10))        tel(char(11))

sample2
no(integer)     name(varchar(10))        fax(char(11))