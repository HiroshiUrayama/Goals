'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'デッドロック
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
2つ以上の処理がお互いにロック解除待ちになった状態
    PostgreSQL
        デッドロックを検知
            対象のトランザクションをロールバックする
                自動で回復させる機能がある

例：
    A：BEGIN
    B：BEGIN
    A：SELECT * FROM item WHERE itemId='0011' FOR UPDATE;
        itemテーブル表示、ロックを掛ける
    B：SELECT * FROM sales WHERE itemId='0011' FOR UPDATE;
        salesテーブル表示、ロックを掛ける
    A：SELECT * FROM sales WHERE itemId='0011' FOR UPDATE;
        salesテーブルはロックが掛かっているのでロック解除待ちになる
    B：SELECT * FROM item WHERE itemId='0011' FOR UPDATE;
        itemテーブルはロックが掛かっていて、既にAがBのロックしているsalesテーブルをロック待ちしているため、
        この手続きを取るとB側でデッドロックが発生する
            B側で発生したので、Bのトランザクションがロールバックされる
                A側の処理は、B側の処理が戻ったので実行される

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'行に対するロック
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
1.排他ロック
2.共有ロック

    ※SELECT FOR SHARE
    ※SELECT FOR UPDATE(排他ロック)
        上記のどちらかで行に対するロックを指定できる

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'ACCESS EXCLUSIVEモード(ロックの一種)
'アクセス除外モードってこと？
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
他トランザクションに対して、ロック対象のテーブルへの全ての処理をブロックする

①は、ロックを掛けたトランザクションなので実行可能。
    クライアントA：SELECT * FROM item WHERE price > 1000; ---①
②、③は他トランザクションの処理なので、ロックが解除されるのを待ってから実行される。
    クライアントB：DELETE FROM item WHERE id = 'S001'; ---②
    クライアントB：SELECT * FROM item; ---③

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'テーブル全体のロック
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
書式
    LOCK TABLE テーブル名 IN ロックモード MODE

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'トランザクション分離レベル
'https://qiita.com/song_ss/items/38e514b05e9dabae3bdb
'↑のQiitaの記事がわかりやすい
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
他トランザクションの処理に影響されない(分離性がある)
    【分離ができる】
        最弱：READ UNCOMMITTED
            ダーティーリード／× ファジーリード／×   ファントムリード／×
        弱：READ COMMITTED(PostgreSQLのデフォルト)
            ダーティーリード／○ ファジーリード／×   ファントムリード／×
        強：REPEATABLE READ
            ダーティーリード／○ ファジーリード／○   ファントムリード／○
        最強：SERIALIZABLE
            全部防げる

        ※PostgreSQLでREADUNCOMMITEDを設定すると、
        内部でREADCOMMITTEDが設定されるため、
        実際の挙動としてはダーティーリードのみを防ぐことができる(親切設計？)

    【分離できない】
        DIRTY READ
            他トランザクションによって変更された、コミット前のデータを読み込んでしまう現象

        FAZZY READ
            あるデータをトランザクション内で複数回読み込んだ場合に、
            対象のデータが他トランザクションで更新・削除されてコミットされることにより、
            取得されるデータ内容が変わってしまう現象のこと。
                分離性の弱さが原因で生じる。

        PHANTOM READ
            あるデータをトランザクション内で複数回読み込んだ場合に、
            他トランザクションでデータの挿入がコミットされることによって以前は取得されなかった
            データが取得されてしまう現象

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'トランザクション分離レベルのSQLでの設定
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
①SET文を使用した指定方法(セッション単位)
    SET default_transaction_isolation TO '分離レベル';

②SET文を使用した指定方法(トランザクション単位)
    SET TRANSACTION ISOLATION LEVEL 分離レベル;

【トランザクションの開始時に指定する必要がある】
③トランザクションの制御コマンドを使用した指定方法(トランザクション単位)
    (トランザクションの開始時に指定する)
    BEGIN ISOLATION LEVEL 分離レベル;
    START TRANSACTION ISOLATION LEVEL 分離レベル;

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'トランザクションの制御コマンド
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
BEGIN
START TRANSACTION
    トランザクションを開始する

COMMIT
END
    トランザクションを終了し、トランザクションの処理を確定する

ROLLBACK
ABORT
    トランザクションを停止し、トランザクションの処理を取り消す

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'トランザクション内でエラーが生じた場合
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
構文エラーが発生(構文エラーでトランザクションが再度開始することはない)
    トランザクション内でエラーが発生した場合
        ロールバック以外の処理を受け付けなくなる
            トランザクション内の処理は全て取り消される。

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'トランザクションのACID特性
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Atoicity(原子性)
    トランザクションの一連の処理が完全な状態で実行される場合のみ実行され、
    不完全な場合は全く実行されない性質
        ※トランザクション内で構文エラーが起きた場合、トランザクションの全ての処理が取り消される

Consistency(整合性)
    トランザクションの実行前後でデータベースの整合性が保たれる性質

Isolation(分離性)
    トランザクションの処理が他のトランザクションの処理に影響を与えたり受けたりしない性質

Durabilitiy(持続性)
    トランザクションのコミットにより変更された内容が確実に保存される性質

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'savepoint
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
トランザクション内の処理を一部だけ取り消す場合に使用する。
    セーブポイントを設定する場合：
        SAVEPOINT セーブポイント名;

    セーブポイントまで処理を戻す場合：
        ROLLBACK TO セーブポイント名;

    セーブポイントを削除する：
        RELEASE SAVEPOINT セーブポイント名;
            同じ名前のセーブポイントを作成した場合はセーブポイントが上書きされるため、
            削除すると上書き前のセーブポイントに戻る

    例：
        BEGIN;
        CREATE TABLE sample(id INTEGER);
        INSERT INTO sample VALUES(1);   1
        INSERT INTO sample VALUES(2);   2
        SAVEPOINT sp;
        INSERT INTO sample VALUES(3);   3
        SAVEPOINT sp;
        INSERT INTO sample VALUES(4);   4
        RELEASE SAVEPOINT sp;   セーブポイントsp(2つ目)が消える 3件分になる
        ROLLBACK TO sp;             1つ目のセーブポイントに戻るので2件のデータ
        SELECT * FROM sample;
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'自動コミット
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
BEGIN;
INSERT INTO number VALUES(1, 'one'), (2, 'two'), (3, 'three');
SAVEPOINT s1;
INSERT INTO number VALUES(4, 'four'), (5, 'five');
DELETE FROM number WHERE num = 3;
ROLLBACK TO s1;
COMMIT;

1,2,3までのデータがある

↓ここで、明示的にトランザクションを開始していないので、自動コミットが走る設定
INSERT INTO number VALUES(6, 'six');
    ここで6はコミットされている
ROLLBACK;
    ロールバックしてもコミット済みなので4件
INSERT INTO number VALUES(7, 'seven');
    ここで7はコミット
COMMIT;
    コミットしても既にされている
SELECT count(*) FROM number;
    5件

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'トランザクション中にSETコマンドを使った場合
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
トランザクションがコミットされると変更したパラメータ値はセッション内で保存される。
    セッション内でのみ保持。
    LOCALパラメータを使用するとトランザクション内で保持に変えられる。

トランザクションがロールバックされると変更したパラメータ値はトランザクション開始時の値に戻る

    書式
        SET パラメータ名 TO {設定値 | DEFAULT};
        SET パラメータ名 = {設定値 | DEFAULT};

'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
'SETコマンドの使い方
'＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
PostgreSQLの稼働中にパラメータの設定を変更するコマンド。
スーパユーザ or 一般ユーザによるSETコマンドの実行により、稼働中に設定値を変更できる。
SETコマンドで設定した設定値は、コマンドを実行したセッション(PostgreSQLへの接続)内でのみ有効。
    書式：
        SET パラメータ名 TO{設定値 | DEFAULT};
        SET パラメータ名 = {設定値 | DEFAULT};

    SETの後に追加できるパラメータ
        SESSION(デフォルト)
            SETコマンドの有効範囲を現在のセッションのみにする
        LOCAL
            SETコマンドの有効範囲を現在のトランザクションのみにする
            